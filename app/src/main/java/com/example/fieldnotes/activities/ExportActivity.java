package com.example.fieldnotes.activities;

/*
DEVELOPER NOTES:

This class upon creation immediately calls the Notebook class's "deep" constructor. See the
Notebook class for documentation on that. It essentially returns the Notebook from the
database containing all Stops with all the Stops' pictures.

RtfUtility.createRTF needs to run in its own thread. IT CANNOT RUN ON THE MAIN UI THREAD OR THE
APP WILL CRASH. When the thread it done generating the RTF, it calls the method complete.

The complete method returns control to the main UI thread, so the user can interact with it
again. This generates an implicit intent. That is, any apps that have capabilities to share
an RTF file answers the intent. A popup generated by the OS will show up letting the user choose
which app they want to share that RTF with. The activity ends after this popup displays.

If this activity is stopped, the app finishes. If the RTF thread ends while this app is
not active, the app will likely crash, so it's best to end the activity.
 */

import android.arch.lifecycle.ViewModelProviders;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.StrictMode;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.WindowManager;

import com.example.fieldnotes.R;
import com.example.fieldnotes.database.FieldNotesViewModel;
import com.example.fieldnotes.java.Notebook;
import com.example.fieldnotes.utilities.RtfUtility;

import java.io.File;

/**
 * An <code>Activity</code> that displays a loading bar while the user waits for
 * the app to export the passed <code>Notebook</code> to an RTF document. Finishes once the
 * the document is finished generating.
 *
 * @author Steven Hricenak (2019)
 */
public class ExportActivity extends AppCompatActivity {

    private static final String TAG = "ExportUtility";
    private static final String THIS_UNIX = "Unix Time";

    private FieldNotesViewModel viewModel;

    private Notebook notebook;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_export);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

        viewModel = ViewModelProviders.of(this).get(FieldNotesViewModel.class);

        long unixTime = getIntent().getLongExtra(THIS_UNIX, 0);

        notebook = new Notebook(unixTime, viewModel);

        new Thread(new Runnable() {
            public void run() {
                File file = RtfUtility.createRTF(notebook);
                complete(file);
            }
        }).start();
    }

    /**
     * When this <code>Activity</code> is stopped, it is finished, to prevent any issues with
     * threads.
     */
    @Override
    protected void onStop(){
        super.onStop();
        finish();
    }

    /**
     * Called once the file is done being generated. Sends control back to the main thread so
     * <code>finish</code> can be called. Creates an implicit <code>Intent</code> for sharing
     * a file.
     *
     * @param file The RTF generated.
     */
    private void complete(final File file){
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (file == null) {
                    Log.e(TAG, "RTF could not be generated.");
                    finish();
                }

                StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder();
                StrictMode.setVmPolicy(builder.build());

                Intent intent = new Intent();
                intent.setAction(Intent.ACTION_SEND);
                intent.setType("text/plain");
                Uri uri = Uri.fromFile(file);
                intent.putExtra(Intent.EXTRA_STREAM, uri);

                if (intent.resolveActivity(getPackageManager()) != null)
                    startActivity(intent);
                finish();
            }
        });
    }

}
